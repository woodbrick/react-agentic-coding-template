# 状态层研发规范

## 1. 状态层职责定义

状态层是应用的数据中枢，负责**业务数据存储、数据变更、数据分发**三大核心职责，**不存储 UI 状态**。

状态管理器放在 src/stores/{业务名称}Store/index.ts 目录下。类型定义应内联在 store 文件中，避免单独的 interfaces.ts 文件。这种内联模式增强文件内聚性，减少跨文件依赖，符合状态层作为单一职责单元的设计原则。

编写Store时,需要先判断是否有跨组件共享状态属性的需求,如无必要,不创建Store.

### 1.4 Store 层核心规则

为了保持 store 层的简洁和专注性，必须严格遵守以下核心规则：

1. 优先使用Promise，避免使用 async/await
2. 优先透传整个数据对象, 避免做冗余的数据转化
3. 创建数据时禁止指定 ID，createTime,updateTime, 这些由服务端生成
4. 不保存和处理 loading errors pagination 这些临时交互状态
5. 如果不涉及跨组件复用，列表数据也不用保存
6. 除非有明确诉求，否则不要单独导出计算属性和辅助函数
7. 不自己定义业务数据模型，复用Service层的数据模型定义

### 1.1 数据存储范围

- **服务端数据**：接口返回的原始业务数据
- **业务状态**：与业务逻辑相关的状态（如当前编辑的实体 ID）
- **派生数据**：基于原始数据的计算结果
- **缓存数据**：减少重复请求的数据快照

### 1.2 状态边界

- **业务数据**：仅存储服务端返回的原始数据、业务状态标识和派生计算结果
- **禁止包含**：UI状态（如弹窗显示、滚动位置、悬停状态）
- **判断原则**：若状态仅用于控制组件UI行为，而非业务逻辑，则不属于状态层职责
- **参考**：完整模式请参见 `.context/examples/antd-pro-patterns/pro-table.md`

### 1.3 状态管理边界

store 层专注业务逻辑和状态数据管理, 临时交互状态（如表单筛选条件、分页参数、排序规则等）应由**业务组件自行管理**，不进入Store全局状态层。

#### 临时状态分类

| 状态类型 | 管理主体 | 生命周期 | 示例 |
|---------|---------|----------|------|
| **表格筛选条件** | 业务组件 | 页面会话 | 搜索关键词、筛选器值 |
| **分页参数** | 业务组件 | 当前视图 | 页码、每页大小 |
| **排序规则** | 业务组件 | 用户操作 | 排序字段、排序方向 |
| **展开/折叠** | 业务组件 | 用户交互 | 树节点展开、面板折叠 |

#### 状态管理原则

临时交互状态应由**业务组件自行管理**，不进入全局状态层。

- **必须**：筛选条件、分页参数、排序规则、行选中状态等均由组件通过 useState 或 useRef 管理
- **禁止**：在任何全局状态接口（如 useXXXStore）中定义这些临时状态属性
- **正确做法**：临时状态仅作为查询参数传递给服务端，不持久化于全局 store
- **参考**：完整模式请参见 `.context/examples/antd-pro-patterns/pro-table.md`

**状态层专注业务**：
- 存储服务端返回的核心数据
- 管理跨组件共享的业务状态

## 2. 数据存储规范

### 2.1 存储场景分类

| 场景类型     | 存储策略 | 示例               | 更新频率 |
| ------------ | -------- | ------------------ | -------- |
| **列表数据** | 完整存储 | 模块列表、页面配置 | 低频     |
| **详情数据** | 按需存储 | 当前编辑的模块数据 | 中频     |
| **业务状态** | 最小存储 | 当前编辑的实体 ID  | 高频     |
| **缓存数据** | 快照存储 | 上次更新时间戳     | 按需     |

### 2.2 命名规范

- **目录名**：camelCase，如 `pageConfigStore`
- **文件名**：camelCase，如 `index.ts`
- **函数名**：动宾短语，如 `queryPageConfig`、`savePageData`
- **类型名**：PascalCase，如 `PageQueryParams`

## 3. 状态变更方法

### 3.1 变更场景

| 场景           | 变更方式 | 业务含义       |
| -------------- | -------- | -------------- |
| **数据初始化** | 完整替换 | 加载页面配置   |
| **属性更新**   | 局部更新 | 修改模块配置   |
| **顺序调整**   | 批量更新 | 拖拽排序模块   |
| **数据同步**   | 增量更新 | 服务端数据同步 |

### 3.2 变更模式

- **数据初始化**：完整替换业务数据
- **属性更新**：局部更新业务属性
- **状态变更**：更新业务状态标识
- **数据同步**：与服务端数据保持一致

### 3.3 不可变状态更新模式

- **推荐原则**：所有状态更新必须保持不可变性，禁止直接修改 state 对象
- **常规方法**：对于简单嵌套结构，可使用展开运算符（...）进行浅层复制更新
- **复杂场景**：对于深层嵌套或数组操作，推荐使用 Immer 中间件提升代码可读性与维护性
- **必须**：使用 `produce` 包装更新函数，确保状态更新的安全性和原子性
- **禁止**：在状态更新中直接赋值修改 state 属性（如 state.nested.obj.value = x）
- **参考**：完整实现模式请参见 `.context/examples/antd-pro-patterns/pro-table.md`

#### Immer 使用规范

- **推荐场景**：深层嵌套状态更新、复杂数组/对象操作、需同时更新多个属性、避免重复展开运算符的场景
- **必须**：仅在使用 Zustand 的 `set(produce(...))` 模式时启用 Immer
- **禁止**：在非 Zustand 状态管理中引入 Immer，或在非状态更新逻辑中滥用
- **性能**：大型状态树应进行性能评估，避免无差别使用
- **原子性**：每次 produce 调用应为单一、完整的状态变更
- **参考**：完整实现模式请参见 `.context/examples/antd-pro-patterns/pro-table.md`

## 4. 数据分发方式

### 4.1 业务数据分发

| 使用场景     | 分发策略 | 说明                                   |
| ------------ | -------- | -------------------------------------- |
| **列表渲染** | 全量订阅 | 通过 `useXXXStore()` 订阅整个列表数据  |
| **详情编辑** | 精确订阅 | 通过 `useXXXStore(selector)` 订阅单条数据 |
| **派生计算** | 计算属性 | 使用 `useMemo` 或内置选择器计算派生值  |
| **关联查询** | 组合订阅 | 结合多个状态选择器进行复杂数据关联     |

### 4.2 分发优化

- **大数据分页**：使用分页参数进行数据切片
- **业务实体查找**：通过标识符精确查找
- **业务统计**：实时计算派生数据

## 5. 检查清单

### 5.1 基础检查项

- [ ] 仅存储业务数据，无 UI 状态
- [ ] 数据存储按业务场景分类
- [ ] 变更方法聚焦业务逻辑
- [ ] 分发方式匹配业务需求
- [ ] 派生数据实时计算
- [ ] 大数据场景有优化策略
- [ ] 复杂状态更新使用 Immer 简化代码
- [ ] 深层嵌套状态避免繁琐的展开运算符
- [ ] 临时交互状态由业务组件管理（筛选、分页、排序、选中状态等）

### 5.2 Store 层规则检查

- [ ] 不使用 async/await 异步操作
- [ ] 不进行冗余数据转换
- [ ] 不指定创建数据时的 ID 和 createTime
- [ ] 不保存 errors、pagination、filters、modalVisible、currentPage 等单组件临时交互状态。
- [ ] loading 跨组件状态属性, 可以放在store托管
- [ ] 列表数据按跨组件复用需求决定是否保存
- [ ] 不单独导出不必要的计算属性和辅助函数
- [ ] 不自定义业务数据模型，复用 Service 层定义


#### ✅ 实现方案

状态层应采用以下实现方案：

1. **单一职责**：每个状态管理器仅负责一个业务领域的数据
2. **内联定义**：状态接口（State）和操作接口（Actions）在 store 文件中内联定义，避免跨文件依赖
3. **纯数据存储**：仅存储服务端返回的原始业务数据和与业务逻辑直接相关的核心状态标识
4. **派生计算**：所有派生状态（如当前选中项、过滤结果）通过选择器函数实时计算，不存储在状态中
5. **错误传递**：错误信息仅作为状态字段保留，不进行业务逻辑处理
6. **异步模式**：所有异步操作返回 Promise，不使用 async/await 语法
7. **不变性**：使用 Immer 进行状态更新，确保状态不可变

状态层不应处理以下内容：
- UI 状态（加载中、错误提示、分页、筛选条件、模态框显示）
- 组件级交互状态（排序规则、展开/折叠、选中行）
- 数据转换逻辑
- 业务规则验证

状态层与组件层的职责边界：
- **状态层**：负责业务数据的存储、变更和分发
- **组件层**：负责 UI 行为、交互状态和用户输入的管理

状态层数据流：
服务端 API → 状态层（存储原始数据） → 组件层（通过选择器获取并计算派生状态） → 用户界面

**禁止模式**：
- 将 UI 状态与业务数据混合在同一个状态对象中
- 在状态层中实现 UI 控制逻辑
- 依赖组件层的临时状态进行数据变更
- 在状态层中定义业务规则或数据验证逻辑
