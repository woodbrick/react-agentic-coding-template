# 架构解决方案验证检查表

本检查表为架构师提供了一个全面的框架,用于在开发执行前验证技术设计和架构.架构师应系统性地完成每一项检查,确保架构稳健、可扩展并与产品需求一致.

[[LLM: 初始化说明 - 必需工件

在继续本检查表之前,请确保您已获得以下资料:

1. .context/rules/architecture-standards.md - 主架构文档
2. prd.md - 产品需求文档,用于需求对齐
3. .context/rules/component-standards.md - 如果是UI项目
4. 架构中引用的任何系统图
5. 如有,API文档
6. 技术栈详细信息和版本规范

重要:如果任何必需文档缺失或无法访问,请立即向用户询问其位置或内容,然后再继续.

项目类型检测:
首先,通过检查确定项目类型:

- 架构是否包含前端/UI组件？
- 是否有 .context/rules/component-standards.md 文档？
- PRD是否提及用户界面或前端需求？

如果是仅后端或仅服务项目:

- 跳过标记为[[前端仅限]]的部分
- 额外关注API设计、服务架构和集成模式
- 在最终报告中注明由于项目类型而跳过了前端部分

验证方法:
对于每个部分,您必须:

1. 深入分析 - 不要只是勾选框,要彻底分析每个项目与所提供文档的匹配情况
2. 有据可依 - 在验证时引用文档中的具体章节或引用
3. 批判性思维 - 质疑假设并识别差距,而不仅仅是确认存在的内容
4. 风险评估 - 考虑每个架构决策可能出现的问题

执行模式:
询问用户他们希望如何完成检查表:

- 逐部分进行(互动模式) - 审查每个部分,提出发现,确认后再继续
- 一次性完成(综合模式) - 完成完整分析,最后呈现综合报告]]

## 1. 需求对齐

[[LLM: 在评估本部分之前,请花时间充分理解PRD中产品的目的和目标.核心问题是什么？用户是谁？关键成功因素是什么？在验证对齐情况时,请牢记这些要点.对于每个项目,不要只检查是否提及,还要验证架构是否提供了具体的技术解决方案.]]

### 1.1 功能需求覆盖

- [ ] 架构支持PRD中的所有功能需求
- [ ] 所有PRD和故事的技术方法均已解决
- [ ] 考虑了边缘情况和性能场景
- [ ] 所有所需集成均已考虑
- [ ] 用户旅程由技术架构支持

### 1.2 非功能需求对齐

- [ ] 性能需求通过具体解决方案解决
- [ ] 可扩展性考虑已记录并提供方法
- [ ] 可靠性和弹性方法已定义

### 1.3 技术约束遵守

- [ ] PRD中的所有技术约束均已满足
- [ ] 平台/语言要求已遵守
- [ ] 基础设施约束已适应
- [ ] 第三方服务约束已解决
- [ ] 组织技术标准已遵循

## 2. 架构基础

[[LLM: 架构清晰度对成功实施至关重要.在审查本部分时,想象一下您正在向新开发人员解释系统.是否有任何歧义可能导致误解？AI代理能否在没有困惑的情况下实现此架构？寻找具体的图表、组件定义和清晰的交互模式.]]

### 2.1 架构清晰度

- [ ] 架构配有清晰的图表
- [ ] 主要组件及其职责已定义
- [ ] 组件交互和依赖关系已映射
- [ ] 数据流已清晰展示
- [ ] 每个组件的技术选择已指定

### 2.2 关注点分离

- [ ] UI、业务逻辑和数据层之间有清晰的界限
- [ ] 组件之间的职责明确划分
- [ ] 组件接口定义明确
- [ ] 组件遵守单一职责原则
- [ ] 跨切面关注点(日志、认证等)已妥善处理

### 2.3 设计模式与最佳实践

- [ ] 应用了适当的设计模式
- [ ] 遵循了行业最佳实践
- [ ] 避免了反模式
- [ ] 整个架构风格一致
- [ ] 模式使用已记录并解释

### 2.4 模块化与可维护性

- [ ] 系统分为内聚、松耦合的模块
- [ ] 组件可以独立开发和测试
- [ ] 更改可以局部化到特定组件
- [ ] 代码组织促进可发现性
- [ ] 架构专为AI代理实施设计

## 3. 技术栈与决策

[[LLM: 技术选择具有长期影响.对于每个技术决策,请考虑:这是可行的最简单解决方案吗？我们是否过度工程化？这能扩展吗？维护影响如何？所选版本是否存在安全漏洞？验证是否定义了具体版本,而非范围.]]

### 3.1 技术选型

- [ ] 所选技术满足所有需求
- [ ] 技术版本已明确定义(非范围)
- [ ] 技术选择有明确的合理依据
- [ ] 考虑过的替代方案已记录优缺点
- [ ] 所选技术栈组件能良好协作

### 3.2 前端架构 [[前端仅限]]

[[LLM: 如果这是仅后端或仅服务项目,请跳过整个部分.仅在项目包含用户界面时进行评估.]]

- [ ] 已明确选择UI框架和库
- [ ] 已定义状态管理方法
- [ ] 已指定组件结构和组织
- [ ] 已概述响应式/自适应设计方法
- [ ] 已确定构建和打包策略

### 3.3 后端架构

- [ ] 已定义API设计和标准
- [ ] 服务组织和边界清晰
- [ ] 已指定身份验证和授权方法
- [ ] 已概述错误处理策略
- [ ] 已定义后端扩展方法

## 4. 前端设计与实施 [[前端仅限]]

[[LLM: 对于仅后端项目,应跳过整个部分.仅在项目包含用户界面时进行评估.评估时,确保主架构文档与前端特定架构文档之间的一致性.]]

### 4.1 前端理念与模式

- [ ] 框架和核心库与主架构文档一致
- [ ] 组件架构(例如原子设计)已清晰描述
- [ ] 状态管理策略适用于应用程序复杂性
- [ ] 数据流模式一致且清晰
- [ ] 样式方法已定义并指定了工具

### 4.2 前端结构与组织

- [ ] 目录结构已用ASCII图清晰记录
- [ ] 组件组织遵循所述模式
- [ ] 文件命名约定明确
- [ ] 结构支持所选框架的最佳实践
- [ ] 明确说明了新组件应放置的位置

### 4.3 组件设计

- [ ] 已定义组件模板/规范格式
- [ ] 组件属性、状态和事件已良好文档化
- [ ] 已识别共享/基础组件
- [ ] 已建立组件可重用模式
- [ ] 可访问性要求已融入组件设计

### 4.4 前端-后端集成

- [ ] 已明确定义API交互层
- [ ] 已记录HTTP客户端设置和配置
- [ ] 对API调用的错误处理全面
- [ ] 服务定义遵循一致的模式
- [ ] 与后端的身份验证集成清晰

### 4.5 路由与导航

- [ ] 已指定路由策略和库
- [ ] 路由定义表完整
- [ ] 已定义路由保护机制
- [ ] 已解决深度链接考虑
- [ ] 导航模式一致

## 7. 实施指导

[[LLM: 清晰的实施指导可防止代价高昂的错误.在审查本部分时,想象自己是第一天开始工作的开发人员.他们是否拥有高效工作所需的一切？编码标准是否足够清晰以保持团队的一致性？寻找具体的示例和模式.]]

### 7.1 编码标准与实践

- [ ] 已定义编码标准
- [ ] 已指定文档要求
- [ ] 已概述测试期望
- [ ] 已定义代码组织原则
- [ ] 已指定命名约定

### 7.2 测试策略

- [ ] 已定义单元测试方法
- [ ] 已概述集成测试策略
- [ ] 已指定E2E测试方法
- [ ] 已概述性能测试要求
- [ ] 已定义安全测试方法

### 7.3 前端测试 [[前端仅限]]

[[LLM: 对于仅后端项目,请跳过此小节.]]

- [ ] 已定义组件测试范围和工具
- [ ] 已指定UI集成测试方法
- [ ] 已考虑视觉回归测试
- [ ] 已识别可访问性测试工具
- [ ] 已解决前端特定测试数据管理

### 7.4 开发环境

- [ ] 已记录本地开发环境设置
- [ ] 已指定所需工具和配置
- [ ] 已概述开发工作流程
- [ ] 已定义源代码控制实践
- [ ] 已指定依赖管理方法

### 7.5 技术文档

- [ ] 已定义API文档标准
- [ ] 已指定架构文档要求
- [ ] 已概述代码文档期望
- [ ] 已包含系统图和可视化
- [ ] 已包含关键选择的决策记录

## 8. 依赖与集成管理

[[LLM: 依赖关系通常是生产问题的根源.对于每个依赖关系,请考虑:如果它不可用会发生什么？是否有带有安全补丁的新版本？我们是否被锁定在一个供应商？我们的应急计划是什么？验证具体版本和备用策略.]]

### 8.1 外部依赖

- [ ] 已识别所有外部依赖
- [ ] 已定义依赖关系的版本策略
- [ ] 已为关键依赖指定备用方法
- [ ] 已处理许可含义
- [ ] 已概述更新和补丁策略

### 8.2 内部依赖

- [ ] 组件依赖关系已清晰映射
- [ ] 已解决构建顺序依赖
- [ ] 已识别共享服务和实用程序
- [ ] 已消除循环依赖
- [ ] 已定义内部组件的版本策略

### 8.3 第三方集成

- [ ] 已识别所有第三方集成
- [ ] 已定义集成方法
- [ ] 已处理与第三方的身份验证
- [ ] 已指定集成失败的错误处理
- [ ] 已考虑速率限制和配额

## 9. AI代理实施适用性

[[LLM: 此架构可能由AI代理实施.以极端清晰度进行审查.模式是否一致？复杂性是否最小化？AI代理是否会做出错误的假设？请记住:明确优于隐含.寻找清晰的文件结构、命名约定和实施模式.]]

### 9.1 为AI代理设计的模块化

- [ ] 组件大小适于AI代理实施
- [ ] 组件间依赖关系最小化
- [ ] 组件间有明确定义的接口
- [ ] 组件具有单一、明确定义的职责
- [ ] 文件和代码组织针对AI代理理解进行了优化

### 9.2 清晰度与可预测性

- [ ] 模式一致且可预测
- [ ] 复杂逻辑被分解为更简单的步骤
- [ ] 架构避免过于聪明或晦涩的方法
- [ ] 为不熟悉的模式提供了示例
- [ ] 组件职责明确清晰

### 9.3 实施指导

- [ ] 提供了详细的实施指导
- [ ] 定义了代码结构模板
- [ ] 记录了具体的实施模式
- [ ] 识别了常见陷阱及其解决方案
- [ ] 当有帮助时,提供了类似实现的参考

### 9.4 错误预防与处理

- [ ] 设计减少了实施错误的机会
- [ ] 已定义验证和错误检查方法
- [ ] 在可能的情况下融入了自我修复机制
- [ ] 已明确定义了测试模式
- [ ] 提供了调试指导

## 10. 可访问性实施 [[前端仅限]]

[[LLM: 对于仅后端项目,请跳过本节.可访问性是任何用户界面的核心要求.]]

### 10.1 可访问性标准

- [ ] 强调语义化HTML使用
- [ ] 提供了ARIA实现指南
- [ ] 定义了键盘导航要求
- [ ] 指定了焦点管理方法
- [ ] 解决了屏幕阅读器兼容性

### 10.2 可访问性测试

- [ ] 确定了可访问性测试工具
- [ ] 将测试流程集成到工作流程中
- [ ] 指定了合规目标(WCAG级别)
- [ ] 定义了手动测试程序
- [ ] 概述了自动化测试方法

[[LLM: 最终验证报告生成

现在您已完成检查表,请生成一份全面的验证报告,包括:

1. 执行摘要
   - 整体架构就绪度(高/中/低)
   - 识别的关键风险
   - 架构的关键优势
   - 项目类型(全栈/前端/后端)和评估的部分

2. 部分分析
   - 每个主要部分的通过率(通过项目的百分比)
   - 最令人担忧的失败或差距
   - 需要立即关注的部分
   - 注明因项目类型而跳过的部分

3. 风险评估
   - 按严重程度排列的前5大风险
   - 每个风险的缓解建议
   - 解决问题的时间影响

4. 建议
   - 开发前必须修复的事项
   - 为更好质量应修复的事项
   - 可选改进

5. AI实施就绪度
   - AI代理实施的具体担忧
   - 需要额外澄清的领域
   - 复杂热点区域

6. 前端特定评估(如适用)
   - 前端架构的完整性
   - 主架构文档与前端架构文档之间的对齐情况
   - UI/UX规范覆盖范围
   - 组件设计的清晰度

在呈现报告后,询问用户他们是否希望了解任何特定部分的详细分析,特别是那些有警告或失败的部分.]]




